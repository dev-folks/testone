<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Init Redirect</title>
  <script src="https://telegram.org/js/telegram-web-app.js?59"></script>
  <style>
      .no-interaction {
          pointer-events: none;
          overflow: hidden;

          user-select: none;
          -webkit-user-select: none;
          -moz-user-select: none;
          -ms-user-select: none;

          -webkit-touch-callout: none;

          -webkit-user-drag: none;
          user-drag: none;

          -webkit-overflow-scrolling: none;

          touch-action: none;
      }

  </style>
</head>
<body>
<div class="no-interaction" style="position: absolute; overflow: hidden; top: 0; bottom: 0; left: 0; right: 0; width: 100dvw; height: 100dvh; z-index: 999999; background-color: black; pointer-events: none; touch-action: none; user-drag: none;"></div>
<script>
  document.addEventListener('DOMContentLoaded', function() {
    document.addEventListener('contextmenu', function(e) {
      e.preventDefault();
      return false;
    }, true);

    const noInteractionElement = document.querySelector('.no-interaction');
    if (noInteractionElement) {
      noInteractionElement.addEventListener('contextmenu', function(e) {
        e.preventDefault();
        e.stopPropagation();
        return false;
      }, true);
    }

    const events = ['mousedown', 'mouseup', 'touchstart', 'touchend', 'touchmove', 'click', 'dblclick'];
    events.forEach(event => {
      document.addEventListener(event, e => {
        e.preventDefault();
        e.stopPropagation();
      }, true);
    });

  });

</script>
<script>
  const fallbackUrl = 'https://http.cat/status/599';
  let tgStorage

  function getDate() {
    const now = new Date();

    return Date.UTC(
      now.getUTCFullYear(),
      now.getUTCMonth(),
      now.getUTCDate()
    );
  }

  function closeApp() {
    return;
    // Telegram Web.
    try {
      window.parent.postMessage('web_app_close');
    } catch {}
    try {
      webApp?.close()
    } catch {}

    // Telegram for iOS, macOS, Android and Telegram Desktop.
    try {
      window.TelegramWebviewProxy.postEvent('web_app_close');
    } catch {}

    // Telegram for Windows Phone or Android.
    try {
      window.external.notify('web_app_close')
    } catch {}

    location.replace(fallbackUrl);
  }

  class CloudStorage {
    webApp;
    storage;
    initData;
    platform;

    constructor() {
      this.webApp = window.Telegram?.WebApp;
      this.storage = this.webApp?.CloudStorage;
      this.initData = this.webApp?.initData;
      this.platform = this.webApp?.platform;

      if (!this.webApp) {
        alert('no webapp')
      }

      if (!this.initData) {
        alert('no initData')
      }

      if (!this.storage) {
        alert('no storage')
      }

      if (!this.platform) {
        alert('no platform')
      }

      if (!this.webApp || !this.storage || !this.initData || !this.platform) {
        closeApp()
      }
    }

    async getValue(key, timeout = 8000) {
      return new Promise((resolve) => {
        const timeoutId = setTimeout(() => {
          resolve(null);
        }, timeout);

        try {
          this.storage.getItem(key, (err, value) => {
            clearTimeout(timeoutId);
            if (err || !value) {
              resolve(null);
            } else {
              resolve(value);
            }
          });
        } catch {
          clearTimeout(timeoutId);
          resolve(null);
        }
      });
    }

    async setValue(key, value, timeout = 8000) {
      return new Promise((resolve) => {
        const timeoutId = setTimeout(() => {
          resolve(false);
        }, timeout);

        try {
          this.storage.setItem(key, value, (err, status) => {
            clearTimeout(timeoutId);
            if (err || status !== true) {
              resolve(false);
            } else {
              resolve(status);
            }
          });
        } catch {
          clearTimeout(timeoutId);
          resolve(false);
        }
      })
    }

    async getJson(key, timeout = 8000) {
      try {
        const result = await this.getValue(key, timeout);
        if (!result) {
          return null
        }

        return JSON.parse(result)
      }
      catch {
        return null;
      }
    }

    async setJson(key, value, timeout = 8000) {
      try {
        const payload = JSON.stringify(value)
        const result = await this.setValue(key, payload, timeout);
        if (!result) {
          return false
        }

        return result
      }
      catch {
        return null;
      }
    }
  }

  function redirect({
    origin,
    pathname,
    token = null,
    includeHash = false,
  }) {
    try {
      const hostname = new URL(origin).hostname;
      const redirectUrl = new URL(window.location.href)
      redirectUrl.hostname = hostname;
      redirectUrl.protocol = 'https:';
      redirectUrl.pathname = pathname;
      if (includeHash)
        redirectUrl.searchParams.set('hash', redirectUrl.hash);
      if (token)
        redirectUrl.searchParams.set('x-my-token', token);

      location.replace(redirectUrl.toString());
    }
    catch {
      closeApp()
    }
  }

  async function auth(origin, pathname = '/miniapp/api/auth/direct') {
    try {
      const response = await fetch(new URL(pathname, origin), {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ initData: tgStorage.initData, platform: tgStorage.platform }),
      });

      if (!response.ok) {
        closeApp()
      }

      const data = await response.json();

      if (!data.origin || !data.pathname) {
        closeApp()
      }

      return data
    }
    catch {
      closeApp()
    }
  }

  async function isDomainReachable(origin, timeout = 8000) {
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), timeout);

    try {
      const res = await fetch(new URL(origin), {
        mode: 'no-cors',
        signal: controller.signal,
        method: 'HEAD'
      });

      return res.type === 'opaque';
    } catch {
      return false;
    } finally {
      clearTimeout(timeoutId);
    }
  }

  (async function run() {
    try {
      tgStorage = new CloudStorage();

      let reqState = await tgStorage.getJson('reqState')
      if (!reqState) {
        reqState = {
          url: '',
          reqDate: getDate(),
          reqCount: 0
        }
      }
      if (reqState?.url && await isDomainReachable(reqState.url)) {
        const data = await auth(reqState.url)

        return redirect(data);
      }

      if (reqState.reqCount >= 3 && reqState.reqDate === getDate()) {
        return closeApp()
      }

      reqState.reqCount++
      reqState.reqDate = getDate()
      await tgStorage.setJson('reqState', reqState)

      const newData = await auth('https://restless-hat-54ab.dev03.workers.dev', '');
      if (reqState.url === newData.origin) {
        return closeApp()
      }

      reqState.url = newData.origin
      await tgStorage.setJson('reqState', reqState)

      if (await isDomainReachable(newData.origin)) {
        return redirect({ ...newData, includeHash: true });
      }
      else {
        return closeApp()
      }
    }
    catch {
      closeApp()
    }
  })()

</script>
</body>
</html>
